{"version":3,"sources":["cdg.js"],"names":["define","CDGDecoder","canvasEl","borderEl","reset_cdg_state","internal_current_pack","internal_border_index","clear_palette","clear_vram","clear_dirty_blocks","get_current_pack","redraw_canvas","internal_border_dirty","internal_screen_dirty","internal_border_div","style","backgroundColor","palette_index_to_rgb_tuple","render_screen_to_rgb","internal_rgba_context","putImageData","internal_rgba_imagedata","local_context","local_rgba_imagedata","local_dirty","internal_dirty_blocks","local_fontwidth","CDG_ENUM","FONT_WIDTH","local_fontheight","FONT_HEIGHT","blk","y_blk","NUM_X_FONTS","x_blk","render_block_to_rgb","decode_packs","cdg_file_data","playback_position","curr_pack","start_offset","charCodeAt","TV_GRAPHICS","this_pack","slice","MEMORY_PRESET","proc_MEMORY_PRESET","BORDER_PRESET","proc_BORDER_PRESET","LOAD_CLUT_LO","LOAD_CLUT_HI","proc_LOAD_CLUT","COPY_FONT","XOR_FONT","proc_WRITE_FONT","SCROLL_PRESET","SCROLL_COPY","proc_DO_SCROLL","requested_index","internal_palette","fill_line_with_palette_index","adjusted_value","total_palette_entries","PALETTE_ENTRIES","idx","color_index","local_vram","internal_vram","total_vram_size","length","packed_line_value","pxl","local_rgba","data","local_pal","vis_height","VISIBLE_HEIGHT","vram_loc","rgb_loc","curr_rgb","curr_line_indices","y_pxl","x_pxl","x_start","y_start","vram_inc","vram_end","VISIBLE_WIDTH","rgb_inc","cdg_pack","new_border_index","local_palette","pal_offset","pal_inc","temp_idx","temp_rgb","temp_entry","subcode_channel","xor_var","x_location","y_location","start_pixel","current_indexes","current_row","temp_pxl","y_inc","pix_pos","direction","copy_flag","color","proc_VRAM_HSCROLL","proc_VRAM_VSCROLL","x_src","y_src","buf","line_color","dst_idx","src_idx","offscreen_size","Array","VRAM_HEIGHT","NUM_Y_FONTS","getContext","createImageData","this","CDGPlayer","containerId","initOptions","handleCDGHttpRequest","cdgHttpRequest","readyState","status","Error","cdgData","responseText","handleAudioError","audioPlayer","error","error_result","code","updatePlayPosition","position_to_play","play_position","Math","floor","currentTime","current_pack","cdgDecoder","setCDGInterval","cdgIntervalID","setInterval","clearCDGInterval","clearInterval","play","pause","stop","parseTrackOptions","trackOptions","isArray","audioFilePrefix","cdgFilePrefix","mediaPath","defaults","audioFormat","cdgFileExtension","audioTypes","loadTrack","trackInfo","XMLHttpRequest","onreadystatechange","open","setRequestHeader","send","audioSourceElement","document","createElement","type","src","appendChild","load","mp3","ogg","containerEl","getElementById","id","className","width","height","offsetWidth","controls","showControls","autoplay","addEventListener","init"],"mappings":"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","file":"cdg.js","sourcesContent":["/*\n *  This library is heavily based upon CD+Graphics Magic HTML5 CD+G Player\n *  (http://cdgmagic.sourceforge.net/html5_cdgplayer/), which\n *  is distributed under the following licence conditions:\n *\n *  CD+Graphics Magic is free software: you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License as\n *  published by the Free Software Foundation, either version 2 of the\n *  License, or (at your option) any later version.\n *\n *  CD+Graphics Magic is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with CD+Graphics Magic. If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*global define document setInterval clearInterval XMLHttpRequest */\n\ndefine(\"cdg\", [], function() {\n  \"use strict\";\n\n  function CDGDecoder(canvasEl, borderEl) {\n\n    var CDG_ENUM = {\n      VRAM_HEIGHT: 216,    // Height of VRAM, in pixels.\n      VISIBLE_WIDTH: 288,    // Width (or pitch) of visible screen, in pixels.\n      VISIBLE_HEIGHT: 192,    // Height of visible screen, in pixels.\n      FONT_WIDTH: 6,    // Width of  one \"font\" (or block).\n      FONT_HEIGHT: 12,    // Height of one \"font\" (or block).\n      NUM_X_FONTS: 50,    // Number of horizontal fonts contained in VRAM.\n      NUM_Y_FONTS: 18,    // Number of vertical fonts contained in VRAM.\n      PALETTE_ENTRIES: 16,    // Number of CLUT palette entries.\n      TV_GRAPHICS: 0x09,    // 50x18 (48x16) 16 color TV graphics mode.\n      MEMORY_PRESET: 0x01,    // Set all VRAM to palette index.\n      BORDER_PRESET: 0x02,    // Set border to palette index.\n      LOAD_CLUT_LO: 0x1E,    // Load Color Look Up Table index 0 through 7.\n      LOAD_CLUT_HI: 0x1F,    // Load Color Look Up Table index 8 through 15.\n      COPY_FONT: 0x06,    // Copy 12x6 pixel font to screen.\n      XOR_FONT: 0x26,    // XOR 12x6 pixel font with existing VRAM values.\n      SCROLL_PRESET: 0x14,    // Update scroll offset, copying if 0x20 or 0x10.\n      SCROLL_COPY: 0x18     // Update scroll offset, setting color if 0x20 or 0x10.\n    };\n\n    var internal_border_div = borderEl; // DIV element behind graphics canvas.\n    var internal_rgba_context = canvasEl.getContext(\"2d\");  // 2D context of canvas element.\n    var internal_rgba_imagedata = internal_rgba_context.createImageData(CDG_ENUM.VISIBLE_WIDTH, CDG_ENUM.VISIBLE_HEIGHT);  // 288x192 image data.\n    var internal_palette = new Array(CDG_ENUM.PALETTE_ENTRIES);                     // Array containing the 16 RGB palette entries.\n    var internal_vram = new Array(CDG_ENUM.NUM_X_FONTS * CDG_ENUM.VRAM_HEIGHT);  // Array used for graphics VRAM.\n\n    var internal_border_index = 0x00;  // The current border palette index.\n    var internal_current_pack = 0x00;  // The current playback position.\n\n    var internal_border_dirty = false;            // State variable used to determine if the background DIV needs updated.\n    var internal_screen_dirty = false;            // State variable used to determine if a full screen update is needed.\n    var internal_dirty_blocks = new Array(900);  // Array used to determine if a given font/block has changed.\n\n    // Reset all the CDG state variables back to initial values.\n    function reset_cdg_state() {\n      internal_current_pack = 0x00;\n      internal_border_index = 0x00;\n      clear_palette();\n      clear_vram(0x00);\n      clear_dirty_blocks();\n    }\n\n    function get_current_pack() {\n      return internal_current_pack;\n    }\n\n    function redraw_canvas() {\n      // If the border color has changed, then update the background div color.\n      if (internal_border_dirty || internal_screen_dirty) {\n        internal_border_div.style.backgroundColor = palette_index_to_rgb_tuple(internal_border_index);\n        internal_border_dirty = false;\n      }\n\n      // If the screen is dirty, then it needs a full update.\n      if (internal_screen_dirty) {\n        render_screen_to_rgb();\n        internal_screen_dirty = false;\n        clear_dirty_blocks();\n        internal_rgba_context.putImageData(internal_rgba_imagedata, 0, 0);\n      }\n      else {\n        var local_context = internal_rgba_context;\n        var local_rgba_imagedata = internal_rgba_imagedata;\n        var local_dirty = internal_dirty_blocks;\n        var local_fontwidth = CDG_ENUM.FONT_WIDTH;\n        var local_fontheight = CDG_ENUM.FONT_HEIGHT;\n        var blk = 0x00;\n        for (var y_blk = 1; y_blk <= 16; ++y_blk) {\n          blk = y_blk * CDG_ENUM.NUM_X_FONTS + 1;\n          for (var x_blk = 1; x_blk <= 48; ++x_blk) {\n            if (local_dirty[blk]) {\n              render_block_to_rgb(x_blk, y_blk);\n              local_context.putImageData(local_rgba_imagedata, 0, 0,\n                (x_blk - 1) * local_fontwidth,\n                (y_blk - 1) * local_fontheight,\n                local_fontwidth,\n                local_fontheight);\n              local_dirty[blk] = 0x00;\n            }\n            ++blk;\n          }\n        }\n      }\n    }\n\n    // Decode to pack playback_position, using cdg_file_data.\n    function decode_packs(cdg_file_data, playback_position) {\n      for (var curr_pack = internal_current_pack; curr_pack < playback_position; curr_pack++) {\n        var start_offset = curr_pack * 24;\n        var curr_command = cdg_file_data.charCodeAt(start_offset) & 0x3F;\n        if (curr_command == CDG_ENUM.TV_GRAPHICS) {\n          // Slice the file array down to a single pack array.\n          var this_pack = cdg_file_data.slice(start_offset, start_offset + 24);\n          // Pluck out the graphics instruction.\n          var curr_instruction = this_pack.charCodeAt(1) & 0x3F;\n          // Perform the instruction action.\n          switch (curr_instruction) {\n            case CDG_ENUM.MEMORY_PRESET:\n              proc_MEMORY_PRESET(this_pack);\n              break;\n            case CDG_ENUM.BORDER_PRESET:\n              proc_BORDER_PRESET(this_pack);\n              break;\n\n            case CDG_ENUM.LOAD_CLUT_LO:\n            case CDG_ENUM.LOAD_CLUT_HI:\n              proc_LOAD_CLUT(this_pack);\n              break;\n\n            case CDG_ENUM.COPY_FONT:\n            case CDG_ENUM.XOR_FONT:\n              proc_WRITE_FONT(this_pack);\n              break;\n\n            case CDG_ENUM.SCROLL_PRESET:\n            case CDG_ENUM.SCROLL_COPY:\n              proc_DO_SCROLL(this_pack);\n              break;\n          }\n        }\n      }\n      internal_current_pack = playback_position;\n    }\n\n    // Convenience function to return the string \"rgb(r,g,b)\" CSS style tuple of a palette index.\n    function palette_index_to_rgb_tuple(requested_index) {\n      return \"rgb(\" + (internal_palette[requested_index] >> 16 & 0xFF) + \",\" + (internal_palette[requested_index] >> 8 & 0xFF) + \",\" + (internal_palette[requested_index] >> 0 & 0xFF) + \")\";\n    }\n\n    // Convenience function to return a line of special packed palette values.\n    function fill_line_with_palette_index(requested_index) {\n      var adjusted_value = requested_index;           // Pixel 0\n      adjusted_value |= (requested_index << 4);  // Pixel 1\n      adjusted_value |= (requested_index << 8);  // Pixel 2\n      adjusted_value |= (requested_index << 12);  // Pixel 3\n      adjusted_value |= (requested_index << 16);  // Pixel 4\n      adjusted_value |= (requested_index << 20);  // Pixel 5\n      return adjusted_value;\n    }\n\n    // Reset the state of all font/blocks to clean.\n    function clear_dirty_blocks() {\n      for (var blk = 0; blk < 900; blk++) {\n        internal_dirty_blocks[blk] = 0x00;\n      }\n    }\n\n    // Reset all the palette RGB values to black.\n    function clear_palette() {\n      var total_palette_entries = CDG_ENUM.PALETTE_ENTRIES;\n      for (var idx = 0; idx < total_palette_entries; idx++) {\n        internal_palette[idx] = 0x00;\n      }\n    }\n\n    // Set all the VRAM index values to requested index.\n    function clear_vram(color_index) {\n      var local_vram = internal_vram;\n      var total_vram_size = local_vram.length;\n      var packed_line_value = fill_line_with_palette_index(color_index);\n      for (var pxl = 0; pxl < total_vram_size; pxl++) {\n        local_vram[pxl] = packed_line_value;\n      }\n      internal_screen_dirty = true;\n    }\n\n    function render_screen_to_rgb() {\n      var local_rgba = internal_rgba_imagedata.data;\n      var local_pal = internal_palette;\n      var local_vram = internal_vram;\n      var vis_width = 48;\n      var vis_height = CDG_ENUM.VISIBLE_HEIGHT;\n\n      var vram_loc = 601;   // Offset into VRAM array.\n      var rgb_loc = 0x00;  // Offset into RGBA array.\n      var curr_rgb = 0x00;          // RGBA value of current pixel.\n      var curr_line_indices = 0x00; // Packed font row index values.\n\n      for (var y_pxl = 0; y_pxl < vis_height; ++y_pxl) {\n        for (var x_pxl = 0; x_pxl < vis_width; ++x_pxl) {\n          curr_line_indices = local_vram[vram_loc++];              // Get the current line segment indices.\n          curr_rgb = local_pal[(curr_line_indices >> 0) & 0x0F];  // Get the RGB value for pixel 0.\n          local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 0.\n          local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 0.\n          local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 0.\n          local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 0.\n          curr_rgb = local_pal[(curr_line_indices >> 4) & 0x0F];  // Get the RGB value for pixel 1.\n          local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 1.\n          local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 1.\n          local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 1.\n          local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 1.\n          curr_rgb = local_pal[(curr_line_indices >> 8) & 0x0F];  // Get the RGB value for pixel 2.\n          local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 2.\n          local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 2.\n          local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 2.\n          local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 2.\n          curr_rgb = local_pal[(curr_line_indices >> 12) & 0x0F];  // Get the RGB value for pixel 3.\n          local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 3.\n          local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 3.\n          local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 3.\n          local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 3.\n          curr_rgb = local_pal[(curr_line_indices >> 16) & 0x0F];  // Get the RGB value for pixel 4.\n          local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 4.\n          local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 4.\n          local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 4.\n          local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 4.\n          curr_rgb = local_pal[(curr_line_indices >> 20) & 0x0F];  // Get the RGB value for pixel 5.\n          local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 5.\n          local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 5.\n          local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 5.\n          local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 5.\n          // Or, instead, index 0 could be set transparent to show background image/video.\n          // Alternately, SET_TRANSPARENT instruction could be implemented to set 6bit transparency.\n          // Unfortunately, I don't think many (any?) discs bother to set it :-/...\n        }\n        vram_loc += 2;  // Skip the offscreen font blocks.\n      }\n    }\n\n    function render_block_to_rgb(x_start, y_start) {\n      var local_rgba = internal_rgba_imagedata.data;\n      var local_pal = internal_palette;\n      var local_vram = internal_vram;\n\n      var vram_loc = (y_start * CDG_ENUM.NUM_X_FONTS * CDG_ENUM.FONT_HEIGHT) + x_start;  // Offset into VRAM array.\n      var vram_inc = CDG_ENUM.NUM_X_FONTS;\n      var vram_end = vram_loc + (CDG_ENUM.NUM_X_FONTS * CDG_ENUM.FONT_HEIGHT);       // VRAM location to end.\n      var rgb_loc = (y_start - 1) * CDG_ENUM.FONT_HEIGHT * CDG_ENUM.VISIBLE_WIDTH; // Row start.\n      rgb_loc += (x_start - 1) * CDG_ENUM.FONT_WIDTH;                           // Column start\n      rgb_loc *= 4;                                                             // RGBA, 1 pxl = 4 bytes.\n      var rgb_inc = (CDG_ENUM.VISIBLE_WIDTH - CDG_ENUM.FONT_WIDTH) * 4;\n      var curr_rgb = 0x00;          // RGBA value of current pixel.\n      var curr_line_indices = 0x00; // Packed font row index values.\n\n      while (vram_loc < vram_end) {\n        curr_line_indices = local_vram[vram_loc];                // Get the current line segment indices.\n        curr_rgb = local_pal[(curr_line_indices >> 0) & 0x0F];  // Get the RGB value for pixel 0.\n        local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 0.\n        local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 0.\n        local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 0.\n        local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 0.\n        curr_rgb = local_pal[(curr_line_indices >> 4) & 0x0F];  // Get the RGB value for pixel 1.\n        local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 1.\n        local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 1.\n        local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 1.\n        local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 1.\n        curr_rgb = local_pal[(curr_line_indices >> 8) & 0x0F];  // Get the RGB value for pixel 2.\n        local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 2.\n        local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 2.\n        local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 2.\n        local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 2.\n        curr_rgb = local_pal[(curr_line_indices >> 12) & 0x0F];  // Get the RGB value for pixel 3.\n        local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 3.\n        local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 3.\n        local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 3.\n        local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 3.\n        curr_rgb = local_pal[(curr_line_indices >> 16) & 0x0F];  // Get the RGB value for pixel 4.\n        local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 4.\n        local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 4.\n        local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 4.\n        local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 4.\n        curr_rgb = local_pal[(curr_line_indices >> 20) & 0x0F];  // Get the RGB value for pixel 5.\n        local_rgba[rgb_loc++] = (curr_rgb >> 16) & 0xFF;        // Set red value for pixel 5.\n        local_rgba[rgb_loc++] = (curr_rgb >> 8) & 0xFF;        // Set green value for pixel 5.\n        local_rgba[rgb_loc++] = (curr_rgb >> 0) & 0xFF;        // Set blue value for pixel 5.\n        local_rgba[rgb_loc++] = 0xFF;                            // Set alpha value (fully opaque) for pixel 5.\n        // Or, instead, index 0 could be set transparent to show background image/video.\n        // Alternately, SET_TRANSPARENT instruction could be implemented to set 6bit transparency.\n        // Unfortunately, I don't think many (any?) discs bother to set it :-/...\n        vram_loc += vram_inc; // Move to the first column of the next row of this font block in VRAM.\n        rgb_loc += rgb_inc;  // Move to the first column of the next row of this font block in RGB pixels.\n      }\n    }\n\n    function proc_BORDER_PRESET(cdg_pack) {\n      // NOTE: The \"border\" is actually a DIV element, which can be very expensive to change in some browsers.\n      // This somewhat bizarre check ensures that the DIV is only touched if the actual RGB color is different,\n      // but the border index variable is always set... A similar check is also performed during palette update.\n      var new_border_index = cdg_pack.charCodeAt(4) & 0x3F; // Get the border index from subcode.\n      // Check if the new border **RGB** color is different from the old one.\n      if (internal_palette[new_border_index] != internal_palette[internal_border_index]) {\n        internal_border_dirty = true;                     // Border needs updating.\n      }\n      internal_border_index = new_border_index;             // Set the new index.\n    }\n\n    function proc_MEMORY_PRESET(cdg_pack) {\n      clear_vram(cdg_pack.charCodeAt(4) & 0x3F);\n    }\n\n\n    function proc_LOAD_CLUT(cdg_pack) {\n      var local_palette = internal_palette;\n      // If instruction is 0x1E then 8*0=0, if 0x1F then 8*1=8 for offset.\n      var pal_offset = (cdg_pack.charCodeAt(1) & 0x01) * 8;\n      // Step through the eight color indices, setting the RGB values.\n      for (var pal_inc = 0; pal_inc < 8; pal_inc++) {\n        var temp_idx = pal_inc + pal_offset;\n        var temp_rgb = 0x00000000;\n        var temp_entry = 0x00000000;\n        // Set red.\n        temp_entry = (cdg_pack.charCodeAt(pal_inc * 2 + 4) & 0x3C) >> 2;\n        temp_rgb |= (temp_entry * 17) << 16;\n        // Set green.\n        temp_entry = ((cdg_pack.charCodeAt(pal_inc * 2 + 4) & 0x03) << 2) | ((cdg_pack.charCodeAt(pal_inc * 2 + 5) & 0x30) >> 4);\n        temp_rgb |= (temp_entry * 17) << 8;\n        // Set blue.\n        temp_entry = cdg_pack.charCodeAt(pal_inc * 2 + 5) & 0x0F;\n        temp_rgb |= (temp_entry * 17) << 0;\n        // Put the full RGB value into the index position, but only if it's different.\n        if (temp_rgb != local_palette[temp_idx]) {\n          local_palette[temp_idx] = temp_rgb;\n          internal_screen_dirty = true; // The colors are now different, so we need to update the whole screen.\n          if (temp_idx == internal_border_index) {\n            internal_border_dirty = true;\n          } // The border color has changed.\n        }\n      }\n    }\n\n    function proc_WRITE_FONT(cdg_pack) {\n      var local_vram = internal_vram;\n      var local_dirty = internal_dirty_blocks;\n      // Hacky hack to play channels 0 and 1 only... Ideally, there should be a function and user option to get/set.\n      var active_channels = 0x03;\n      // First, get the channel...\n      var subcode_channel = ((cdg_pack.charCodeAt(4) & 0x30) >> 2) | ((cdg_pack.charCodeAt(5) & 0x30) >> 4);\n      var xor_var = cdg_pack.charCodeAt(1) & 0x20;\n      // Then see if we should display it.\n      if ((active_channels >> subcode_channel) && 0x01) {\n        var x_location = cdg_pack.charCodeAt(7) & 0x3F; // Get horizontal font location.\n        var y_location = cdg_pack.charCodeAt(6) & 0x1F; // Get vertical font location.\n\n        // Verify we're not going to overrun the boundaries (i.e. bad data from a scratched disc).\n        if ((x_location <= 49) && (y_location <= 17)) {\n          var start_pixel = y_location * 600 + x_location; // Location of first pixel of this font in linear VRAM.\n          // NOTE: Profiling indicates charCodeAt() uses ~80% of the CPU consumed for this function.\n          // Caching these values reduces that to a negligible amount.\n          var current_indexes = [(cdg_pack.charCodeAt(4) & 0x0F), (cdg_pack.charCodeAt(5) & 0x0F)]; // Current colors.\n          var current_row = 0x00; // Subcode byte for current pixel row.\n          var temp_pxl = 0x00; // Decoded and packed 4bit pixel index values of current row.\n          for (var y_inc = 0; y_inc < 12; y_inc++) {\n            var pix_pos = y_inc * 50 + start_pixel;      // Location of the first pixel of this row in linear VRAM.\n            current_row = cdg_pack.charCodeAt(y_inc + 8);  // Get the subcode byte for the current row.\n            temp_pxl = (current_indexes[(current_row >> 5) & 0x01] << 0);\n            temp_pxl |= (current_indexes[(current_row >> 4) & 0x01] << 4);\n            temp_pxl |= (current_indexes[(current_row >> 3) & 0x01] << 8);\n            temp_pxl |= (current_indexes[(current_row >> 2) & 0x01] << 12);\n            temp_pxl |= (current_indexes[(current_row >> 1) & 0x01] << 16);\n            temp_pxl |= (current_indexes[(current_row >> 0) & 0x01] << 20);\n            if (xor_var) {\n              local_vram[pix_pos] ^= temp_pxl;\n            } else {\n              local_vram[pix_pos] = temp_pxl;\n            }\n          } // End of Y loop.\n          // Mark this block as needing an update.\n          local_dirty[y_location * 50 + x_location] = 0x01;\n        } // End of location check.\n      } // End of channel check.\n    }\n\n    function proc_DO_SCROLL(cdg_pack) {\n      var direction,\n        copy_flag = (cdg_pack.charCodeAt(1) & 0x08) >> 3,\n        color = cdg_pack.charCodeAt(4) & 0x0F;             // Color index to use for preset type.\n\n      // Process horizontal commands.\n      if ((direction = ((cdg_pack.charCodeAt(5) & 0x30) >> 4))) {\n        proc_VRAM_HSCROLL(direction, copy_flag, color);\n      }\n      // Process vertical commands.\n      if ((direction = ((cdg_pack.charCodeAt(6) & 0x30) >> 4))) {\n        proc_VRAM_VSCROLL(direction, copy_flag, color);\n      }\n      internal_screen_dirty = true;  // Entire screen needs to be redrawn.\n    }\n\n    function proc_VRAM_HSCROLL(direction, copy_flag, color) {\n      var x_src,\n        y_src,\n        y_start,\n        buf = 0,\n        line_color = fill_line_with_palette_index(color),\n        local_vram = internal_vram;\n      if (direction == 0x02) {\n        // Step through the lines one at a time...\n        for (y_src = 0; y_src < (50 * 216); y_src += 50) {\n          y_start = y_src;\n          buf = local_vram[y_start];\n          for (x_src = y_start + 1; x_src < y_start + 50; x_src++) {\n            local_vram[x_src - 1] = local_vram[x_src];\n          }\n          if (copy_flag) {\n            local_vram[y_start + 49] = buf;\n          } else {\n            local_vram[y_start + 49] = line_color;\n          }\n        }\n      }\n      else if (direction == 0x01) {\n        // Step through the lines on at a time.\n        for (y_src = 0; y_src < (50 * 216); y_src += 50) {\n          // Copy the last six lines to the buffer.\n          y_start = y_src;\n          buf = local_vram[y_start + 49];\n          for (x_src = y_start + 48; x_src >= y_start; x_src--) {\n            local_vram[x_src + 1] = local_vram[x_src];\n          }\n          if (copy_flag) {\n            local_vram[y_start] = buf;\n          } else {\n            local_vram[y_start] = line_color;\n          }\n        }\n      }\n    }\n\n    function proc_VRAM_VSCROLL(direction, copy_flag, color) {\n      var dst_idx,\n        src_idx,\n        offscreen_size = CDG_ENUM.NUM_X_FONTS * CDG_ENUM.FONT_HEIGHT,\n        buf = new Array(offscreen_size),\n        line_color = fill_line_with_palette_index(color),\n        local_vram = internal_vram;\n      if (direction == 0x02) {\n        dst_idx = 0;  // Buffer destination starts at 0.\n        // Copy the top 300x12 pixels into the buffer.\n        for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\n          buf[dst_idx++] = local_vram[src_idx];\n        }\n        dst_idx = 0; // Destination starts at the first line.\n        for (src_idx = offscreen_size; src_idx < (50 * 216); src_idx++) {\n          local_vram[dst_idx++] = local_vram[src_idx];\n        }\n        dst_idx = (CDG_ENUM.NUM_X_FONTS * 204); // Destination begins at line 204.\n        if (copy_flag) {\n          for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\n            local_vram[dst_idx++] = buf[src_idx];\n          }\n        }\n        else {\n          for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\n            local_vram[dst_idx++] = line_color;\n          }\n        }\n      }\n      else if (direction == 0x01) {\n        dst_idx = 0;  // Buffer destination starts at 0.\n        // Copy the bottom 300x12 pixels into the buffer.\n        for (src_idx = (50 * 204); src_idx < (50 * 216); src_idx++) {\n          buf[dst_idx++] = local_vram[src_idx];\n        }\n        for (src_idx = (50 * 204) - 1; src_idx > 0; src_idx--) {\n          local_vram[src_idx + offscreen_size] = local_vram[src_idx];\n        }\n        if (copy_flag) {\n          for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\n            local_vram[src_idx] = buf[src_idx];\n          }\n        }\n        else {\n          for (src_idx = 0; src_idx < offscreen_size; src_idx++) {\n            local_vram[src_idx] = line_color;\n          }\n        }\n      }\n    }\n\n    // Bind the public functions to member variables.\n    this.get_current_pack = get_current_pack;\n    this.reset_cdg_state = reset_cdg_state;\n    this.redraw_canvas = redraw_canvas;\n    this.decode_packs = decode_packs;\n    this.reset_cdg_state();\n  }\n\n  function CDGPlayer(containerId, initOptions) {\n\n    var defaults = {\n        mediaPath: '',\n        audioFormat: 'mp3',\n        cdgFileExtension: 'cdg'\n      },\n      audioTypes = {\n        mp3: 'audio/mpeg; codecs=\"mp3\"',\n        ogg: 'audio/ogg; codecs=\"vorbis\"'\n      },\n      audioPlayer = null,\n      audioSourceElement = null,\n      cdgIntervalID = null,\n      cdgHttpRequest = null,\n      cdgData = null,\n      cdgDecoder = null;\n\n    function handleCDGHttpRequest() {\n      if (!cdgHttpRequest) {\n        return;\n      }\n      if (cdgHttpRequest.readyState == 4) {\n        if (cdgHttpRequest.status != 200) {\n          throw new Error('CDG file failed to load');\n        }\n        cdgData = cdgHttpRequest.responseText;\n        cdgHttpRequest = null;\n      }\n    }\n\n    function handleAudioError() {\n      if (audioPlayer.error) {\n        var error_result = audioPlayer.error.code ? audioPlayer.error.code : audioPlayer.error;\n        throw new Error(\"The audio control fired an error event. Could be: \" + error_result);\n      }\n    }\n\n    function updatePlayPosition() {\n      if (cdgData != null) {\n        var play_position = Math.floor(audioPlayer.currentTime * 300),\n          current_pack = cdgDecoder.get_current_pack(),\n          position_to_play;\n        play_position = (play_position < 0) ? 0 : play_position;\n        // Render from the beginning of the stream if a reverse seek of more than one second occurred.\n        if (play_position < (current_pack - 300)) {\n          cdgDecoder.reset_cdg_state();\n          current_pack = 0;\n        }\n        position_to_play = current_pack + 6;\n        // Jump to the actual play position if it's ahead of our calculated smoothed position.\n        position_to_play = (play_position > position_to_play) ? play_position : position_to_play;\n        // Check if we should render any packs, and do so if needed.\n        if (position_to_play > current_pack) {\n          cdgDecoder.decode_packs(cdgData, position_to_play);\n          cdgDecoder.redraw_canvas();\n        }\n      }\n    }\n\n    function setCDGInterval() {\n      cdgIntervalID = setInterval(updatePlayPosition, 20);\n    }\n\n    function clearCDGInterval() {\n      clearInterval(cdgIntervalID);\n    }\n\n    function play() {\n      audioPlayer.play();\n    }\n\n    function pause() {\n      audioPlayer.pause();\n    }\n\n    function stop() {\n      audioPlayer.pause();\n      audioPlayer.currentTime = 0;\n    }\n\n    function parseTrackOptions(trackOptions) {\n      if (!trackOptions || Array.isArray(trackOptions) || (typeof trackOptions !== 'string' && typeof trackOptions !== 'object')) {\n        throw new Error('No track information specified, nothing to load!');\n      }\n      var audioFilePrefix,\n        cdgFilePrefix,\n        mediaPath = defaults.mediaPath,\n        audioFormat = defaults.audioFormat,\n        cdgFileExtension = defaults.cdgFileExtension;\n      if (typeof trackOptions === 'object') {\n        if (!trackOptions.audioFilePrefix) {\n          throw new Error('No audioFilePrefix property defined, nothing to load!');\n        } else {\n          audioFilePrefix = trackOptions.audioFilePrefix;\n        }\n        cdgFilePrefix = trackOptions.cdgFilePrefix ? trackOptions.cdgFilePrefix : trackOptions.audioFilePrefix;\n        if (trackOptions.mediaPath) {\n          mediaPath = trackOptions.mediaPath;\n        }\n        if (trackOptions.audioFormat) {\n          if (!audioTypes[trackOptions.audioFormat]) {\n            throw new Error('Unsupported audio format specified');\n          }\n          audioFormat = trackOptions.audioFormat;\n        }\n        if (trackOptions.cdgFileExtension) {\n          cdgFileExtension = trackOptions.cdgFileExtension;\n        }\n      } else {\n        // If only a string has been passed treat it as shorthand for setting the filename prefix for both\n        // audio and CDG files\n        audioFilePrefix = cdgFilePrefix = trackOptions;\n      }\n\n      return {\n        audioFilePrefix: audioFilePrefix,\n        cdgFilePrefix: cdgFilePrefix,\n        mediaPath: mediaPath,\n        audioFormat: audioFormat,\n        cdgFileExtension: cdgFileExtension\n      }\n    }\n\n    function loadTrack(trackOptions) {\n      var trackInfo = parseTrackOptions(trackOptions);\n      clearCDGInterval();\n      cdgDecoder.reset_cdg_state();\n      cdgDecoder.redraw_canvas();\n      cdgData = null;\n      cdgHttpRequest = new XMLHttpRequest();\n      cdgHttpRequest.onreadystatechange = handleCDGHttpRequest;\n      cdgHttpRequest.open(\"GET\", trackInfo.mediaPath + trackInfo.cdgFilePrefix + \".\" + trackInfo.cdgFileExtension, true);\n      cdgHttpRequest.setRequestHeader(\"Content-Type\", \"text/html\");\n      cdgHttpRequest.send();\n      if (audioSourceElement == null) {\n        audioSourceElement = document.createElement(\"source\");\n      }\n      audioSourceElement.type = audioTypes[trackInfo.audioFormat];\n      audioSourceElement.src = trackInfo.mediaPath + trackInfo.audioFilePrefix + \".\" + trackInfo.audioFormat;\n      audioPlayer.appendChild(audioSourceElement);\n      audioPlayer.load();\n      return this;\n    }\n\n    function init(containerId, initOptions) {\n      if (!containerId) {\n        throw new Error(\"Required initialisation parameter missing.\")\n      }\n      var containerEl = document.getElementById(containerId),\n        borderEl = document.createElement(\"div\"),\n        canvasEl = document.createElement(\"canvas\");\n      audioPlayer = document.createElement(\"audio\");\n      borderEl.id = containerId + \"-border\";\n      borderEl.className = \"cdg-border\";\n      canvasEl.id = containerId + \"-canvas\";\n      canvasEl.width = \"288\";\n      canvasEl.height = \"192\";\n      canvasEl.className = \"cdg-canvas\";\n      audioPlayer.id = containerId + \"-audio\";\n      audioPlayer.className = \"cdg-audio\";\n      borderEl.appendChild(canvasEl);\n      containerEl.appendChild(borderEl);\n      containerEl.appendChild(audioPlayer);\n      audioPlayer.style.width = canvasEl.offsetWidth + \"px\";\n      audioPlayer.controls = !(initOptions && initOptions.showControls == false);\n      audioPlayer.autoplay = !(initOptions && initOptions.autoplay == false);\n      audioPlayer.addEventListener(\"error\", handleAudioError, true);\n      audioPlayer.addEventListener(\"play\", setCDGInterval, true);\n      audioPlayer.addEventListener(\"pause\", clearCDGInterval, true);\n      audioPlayer.addEventListener(\"ended\", clearCDGInterval, true);\n      audioPlayer.addEventListener(\"abort\", clearCDGInterval, true);\n      cdgDecoder = new CDGDecoder(canvasEl, borderEl);\n    }\n\n    init(containerId, initOptions);\n\n    // Bind the public functions to member variables.\n    this.loadTrack = loadTrack;\n    this.play = play;\n    this.stop = stop;\n    this.pause = pause;\n  }\n\n  return {\n    init: function(containerId, initOptions) {\n      return new CDGPlayer(containerId, initOptions);\n    }\n  }\n});\n\n"]}